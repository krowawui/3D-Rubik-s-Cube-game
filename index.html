<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Rubik's Cube 3D Premium</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap');

        :root {
            --bg-dark: #0f172a;
            --bg-panel: rgba(30, 41, 59, 0.8);
            --accent: #3b82f6;
            --text-main: #f8fafc;
            --text-muted: #94a3b8;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; -webkit-user-select: none; }

        body {
            font-family: 'Inter', sans-serif;
            background: radial-gradient(circle at center, #1e293b 0%, #020617 100%);
            color: var(--text-main);
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }

        /* 3D Container */
        #canvas-container {
            width: 100%;
            height: 100%;
            display: block;
            touch-action: none; 
            cursor: grab;
        }
        #canvas-container:active { cursor: grabbing; }

        /* UI Overlay */
        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 1rem;
            z-index: 10;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: auto;
        }

        .title-block h1 {
            font-weight: 800;
            font-size: 1.8rem;
            letter-spacing: -0.05em;
            color: white;
            text-shadow: 0 4px 12px rgba(0,0,0,0.5);
        }

        .stats-panel {
            background: var(--bg-panel);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255,255,255,0.1);
            padding: 1rem;
            border-radius: 12px;
            display: flex;
            gap: 1.5rem;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }

        .stat {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .stat-label { font-size: 0.7rem; color: var(--text-muted); text-transform: uppercase; }
        .stat-value { font-size: 1.25rem; font-weight: 600; font-variant-numeric: tabular-nums; color: #60a5fa; }

        /* Manual Controls (Backup) */
        .manual-controls {
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            pointer-events: auto;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 12px;
        }

        .key-btn {
            width: 40px;
            height: 40px;
            border: 1px solid rgba(255,255,255,0.2);
            background: rgba(255,255,255,0.05);
            color: white;
            border-radius: 8px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.1s;
        }
        .key-btn:hover { background: var(--accent); border-color: var(--accent); }
        .key-btn:active { transform: scale(0.95); }

        .bottom-controls {
            display: flex;
            justify-content: center;
            gap: 1rem;
            pointer-events: auto;
            margin-bottom: 1rem;
        }

        .btn {
            background: var(--bg-panel);
            border: 1px solid rgba(255,255,255,0.1);
            color: white;
            padding: 0.8rem 2rem;
            border-radius: 50px;
            font-weight: 600;
            font-size: 0.9rem;
            cursor: pointer;
            backdrop-filter: blur(8px);
            transition: all 0.2s;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            text-transform: uppercase;
        }

        .btn:hover { background: var(--accent); transform: translateY(-2px); }
        .btn:active { transform: translateY(0); }

        .help-text {
            text-align: center;
            color: rgba(255,255,255,0.4);
            font-size: 0.8rem;
            margin-bottom: 0.5rem;
            text-shadow: 0 1px 2px rgba(0,0,0,0.8);
            pointer-events: none;
        }

        /* Toast */
        .toast {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            background: rgba(16, 185, 129, 0.95);
            color: white;
            padding: 1rem 2.5rem;
            border-radius: 12px;
            font-weight: 700;
            font-size: 1.5rem;
            opacity: 0;
            pointer-events: none;
            transition: all 0.4s;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
            z-index: 20;
        }
        .toast.show { opacity: 1; transform: translate(-50%, -50%) scale(1); }

        /* Loader */
        #loader {
            position: fixed;
            inset: 0;
            background: #020617;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            transition: opacity 0.5s;
        }
        .spinner {
            width: 40px; height: 40px;
            border: 3px solid rgba(255,255,255,0.1);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s infinite linear;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
    
    <!-- Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
</head>
<body>

    <div id="loader"><div class="spinner"></div></div>

    <div id="canvas-container"></div>

    <div class="ui-layer">
        <div class="header">
            <div class="title-block"><h1>RUBIKS 3D</h1></div>
            <div class="stats-panel">
                <div class="stat"><span class="stat-label">Moves</span><span class="stat-value" id="move-count">0</span></div>
                <div class="stat"><span class="stat-label">Time</span><span class="stat-value" id="timer">00:00</span></div>
            </div>
        </div>

        <div class="manual-controls">
            <div class="key-btn" onclick="game.move('L', 1)">L</div>
            <div class="key-btn" onclick="game.move('R', -1)">R</div>
            <div class="key-btn" onclick="game.move('U', 1)">U</div>
            <div class="key-btn" onclick="game.move('D', -1)">D</div>
            <div class="key-btn" onclick="game.move('F', 1)">F</div>
            <div class="key-btn" onclick="game.move('B', -1)">B</div>
        </div>

        <div class="toast" id="toast">SOLVED!</div>

        <div class="bottom-area">
            <div class="help-text">
                Drag Background: Rotate Camera • Drag Cube: Rotate Slice • Buttons for Precision
            </div>
            <div class="bottom-controls">
                <button class="btn" style="background:rgba(255,255,255,0.1)" onclick="game.reset()">Reset</button>
                <button class="btn" onclick="game.shuffle()">Shuffle</button>
            </div>
        </div>
    </div>

    <script>
        // --- 1. Texture Generation ---
        function createStickerTexture(colorHex) {
            const size = 512;
            const canvas = document.createElement('canvas');
            canvas.width = size; canvas.height = size;
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = '#111'; ctx.fillRect(0, 0, size, size); // Base black

            const margin = 45; const radius = 60;
            const w = size - margin*2; const h = size - margin*2;

            ctx.fillStyle = colorHex;
            ctx.beginPath(); ctx.roundRect(margin, margin, w, h, radius); ctx.fill();

            // Bevel
            const g = ctx.createLinearGradient(0,0,size,size);
            g.addColorStop(0, 'rgba(255,255,255,0.2)');
            g.addColorStop(1, 'rgba(0,0,0,0.2)');
            ctx.fillStyle = g; ctx.fill();

            ctx.strokeStyle = 'rgba(0,0,0,0.5)'; ctx.lineWidth = 8; ctx.stroke();

            const tex = new THREE.CanvasTexture(canvas);
            tex.anisotropy = 16; return tex;
        }

        const COLORS = { R: '#b90000', L: '#ff5900', U: '#ffd500', D: '#ffffff', F: '#009b48', B: '#0045ad' };
        const TEX = {
            R: createStickerTexture(COLORS.R), L: createStickerTexture(COLORS.L),
            U: createStickerTexture(COLORS.U), D: createStickerTexture(COLORS.D),
            F: createStickerTexture(COLORS.F), B: createStickerTexture(COLORS.B),
            Base: createStickerTexture('#111')
        };

        // --- 2. Game Class ---
        class RubiksGame {
            constructor() {
                this.scene = null; this.camera = null; this.renderer = null; this.controls = null;
                this.cubies = []; this.pivot = null;
                this.raycaster = new THREE.Raycaster(); this.mouse = new THREE.Vector2();
                
                this.isAnimating = false;
                this.isShuffling = false; // New flag
                this.moveCount = 0;
                this.isGameActive = false;
                this.timerInterval = null;

                // Interaction State
                this.isDraggingCube = false;
                this.startMouse = { x: 0, y: 0 };
                this.intersectedCubie = null;
                this.intersectedNormal = null;

                this.init();
            }

            init() {
                const container = document.getElementById('canvas-container');
                
                // Scene
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.FogExp2(0x0f172a, 0.03);

                // Camera
                this.camera = new THREE.PerspectiveCamera(40, window.innerWidth/window.innerHeight, 0.1, 100);
                this.camera.position.set(6, 5, 8);
                this.camera.lookAt(0,0,0);

                // Renderer
                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.shadowMap.enabled = true;
                this.renderer.outputEncoding = THREE.sRGBEncoding;
                container.appendChild(this.renderer.domElement);

                // Lighting
                const ambient = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambient);
                const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
                dirLight.position.set(10, 20, 10);
                dirLight.castShadow = true;
                this.scene.add(dirLight);

                // Pivot
                this.pivot = new THREE.Object3D();
                this.pivot.rotation.order = 'XYZ';
                this.scene.add(this.pivot);

                // Orbit Controls
                this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.enablePan = false;
                this.controls.minDistance = 4; this.controls.maxDistance = 15;

                this.createCube();
                this.setupEvents();
                this.animate();
                
                // Hide loader
                document.getElementById('loader').style.opacity = 0;
                setTimeout(() => document.getElementById('loader').remove(), 500);
            }

            createCube() {
                if(this.cubies.length > 0) this.cubies.forEach(c => this.scene.remove(c));
                this.cubies = [];
                const size = 1; const space = 0.04;
                const geo = new THREE.BoxGeometry(size, size, size);

                for(let x=-1; x<=1; x++) {
                    for(let y=-1; y<=1; y++) {
                        for(let z=-1; z<=1; z++) {
                            // Materials: Right, Left, Top, Bottom, Front, Back
                            const mats = [
                                this.getMat(x===1 ? TEX.R : TEX.Base),
                                this.getMat(x===-1 ? TEX.L : TEX.Base),
                                this.getMat(y===1 ? TEX.U : TEX.Base),
                                this.getMat(y===-1 ? TEX.D : TEX.Base),
                                this.getMat(z===1 ? TEX.F : TEX.Base),
                                this.getMat(z===-1 ? TEX.B : TEX.Base),
                            ];
                            const mesh = new THREE.Mesh(geo, mats);
                            mesh.position.set(x*(size+space), y*(size+space), z*(size+space));
                            
                            // Inner core look
                            const core = new THREE.Mesh(new THREE.BoxGeometry(size*0.96, size*0.96, size*0.96), new THREE.MeshStandardMaterial({color:0x111111}));
                            mesh.add(core);

                            mesh.castShadow = true; mesh.receiveShadow = true;

                            // Store initial state for win checking
                            mesh.userData = {
                                initialPos: mesh.position.clone(),
                                initialQ: mesh.quaternion.clone(),
                                isCore: (x===0 && y===0 && z===0)
                            };

                            this.cubies.push(mesh);
                            this.scene.add(mesh);
                        }
                    }
                }
            }

            getMat(tex) {
                return new THREE.MeshPhysicalMaterial({
                    map: tex, color: 0xffffff, roughness: 0.1, clearcoat: 0.5, clearcoatRoughness: 0.1
                });
            }

            // --- Interaction Logic ---
            setupEvents() {
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth/window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });

                const canvas = this.renderer.domElement;

                canvas.addEventListener('mousedown', (e) => {
                    if (this.isAnimating || e.button !== 0) return;
                    
                    this.mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                    this.mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                    this.raycaster.setFromCamera(this.mouse, this.camera);

                    const intersects = this.raycaster.intersectObjects(this.cubies);

                    if (intersects.length > 0) {
                        this.isDraggingCube = true;
                        this.controls.enabled = false; 
                        this.intersectedCubie = intersects[0].object;
                        this.intersectedNormal = intersects[0].face.normal.clone().transformDirection(this.intersectedCubie.matrixWorld).round();
                        this.startMouse = { x: e.clientX, y: e.clientY };
                    } else {
                        this.isDraggingCube = false;
                        this.controls.enabled = true;
                    }
                });

                window.addEventListener('mouseup', (e) => {
                    if (this.isDraggingCube) {
                        const dx = e.clientX - this.startMouse.x;
                        const dy = e.clientY - this.startMouse.y;
                        
                        if (Math.abs(dx) > 10 || Math.abs(dy) > 10) {
                            this.handleSliceMove(dx, dy);
                        }
                        
                        this.controls.enabled = true;
                        this.isDraggingCube = false;
                        this.intersectedCubie = null;
                    }
                });

                // Touch support
                canvas.addEventListener('touchstart', (e) => {
                    if(e.touches.length > 1) return;
                    const touch = e.touches[0];
                    const me = new MouseEvent('mousedown', { clientX: touch.clientX, clientY: touch.clientY, button: 0 });
                    canvas.dispatchEvent(me);
                }, {passive: false});

                window.addEventListener('touchend', (e) => {
                    if(this.isDraggingCube) {
                        const touch = e.changedTouches[0];
                        const me = new MouseEvent('mouseup', { clientX: touch.clientX, clientY: touch.clientY });
                        window.dispatchEvent(me);
                    }
                });
            }

            handleSliceMove(dx, dy) {
                const nx = Math.abs(this.intersectedNormal.x);
                const ny = Math.abs(this.intersectedNormal.y);
                const nz = Math.abs(this.intersectedNormal.z);

                let possibleAxes = [];
                if (nx > 0.5) possibleAxes = ['y', 'z'];
                else if (ny > 0.5) possibleAxes = ['x', 'z'];
                else possibleAxes = ['x', 'y'];

                let bestAxis = null;
                let maxDot = 0;
                let dragDir = 1;

                const dragVec = new THREE.Vector2(dx, dy).normalize();

                possibleAxes.forEach(axis => {
                    const axisVec = new THREE.Vector3();
                    axisVec[axis] = 1;
                    const p1 = this.intersectedCubie.position.clone().project(this.camera);
                    const p2 = this.intersectedCubie.position.clone().add(axisVec).project(this.camera);
                    const screenAxis = new THREE.Vector2(p2.x - p1.x, p2.y - p1.y).normalize();

                    const dot = Math.abs(dragVec.dot(screenAxis));
                    if (dot > maxDot) {
                        maxDot = dot;
                        bestAxis = axis;
                        const rawDot = dragVec.dot(screenAxis);
                        dragDir = rawDot > 0 ? 1 : -1;
                    }
                });

                if (bestAxis) {
                    const pos = this.intersectedCubie.position;
                    const totalSize = 1.04;
                    let index = 0;
                    if(bestAxis === 'x') index = Math.round(pos.x / totalSize);
                    if(bestAxis === 'y') index = Math.round(pos.y / totalSize);
                    if(bestAxis === 'z') index = Math.round(pos.z / totalSize);

                    const normVal = this.intersectedNormal[bestAxis];
                    let finalDir = dragDir;
                    if (normVal < 0) finalDir *= -1; 
                    finalDir *= -1; 

                    this.rotateLayer(bestAxis, index, finalDir);
                }
            }

            // --- Game Logic ---
            // Added duration parameter
            rotateLayer(axis, index, dir, animate = true, duration = 300) {
                if (this.isAnimating && animate) return;
                this.isAnimating = true;

                const totalSize = 1.04;
                const epsilon = 0.1;
                const layerCubies = this.cubies.filter(c => {
                    const val = c.position[axis];
                    return Math.abs(val - (index * totalSize)) < epsilon;
                });

                this.pivot.rotation.set(0,0,0);
                this.pivot.updateMatrixWorld();
                layerCubies.forEach(c => this.pivot.attach(c));

                const targetRotation = (Math.PI / 2) * dir * -1;

                if (animate) {
                    new TWEEN.Tween({ val: 0 })
                        .to({ val: targetRotation }, duration)
                        .easing(TWEEN.Easing.Cubic.InOut)
                        .onUpdate(o => this.pivot.rotation[axis] = o.val)
                        .onComplete(() => {
                            this.finalizeMove(layerCubies);
                            this.isAnimating = false;
                            this.checkWin();
                        })
                        .start();
                } else {
                    this.pivot.rotation[axis] = targetRotation;
                    this.finalizeMove(layerCubies);
                    this.isAnimating = false;
                }
            }

            finalizeMove(cubies) {
                this.pivot.updateMatrixWorld();
                cubies.forEach(c => {
                    this.scene.attach(c);
                    c.position.x = Math.round(c.position.x / 1.04) * 1.04;
                    c.position.y = Math.round(c.position.y / 1.04) * 1.04;
                    c.position.z = Math.round(c.position.z / 1.04) * 1.04;
                    const e = new THREE.Euler().setFromQuaternion(c.quaternion);
                    e.x = Math.round(e.x/(Math.PI/2))*(Math.PI/2);
                    e.y = Math.round(e.y/(Math.PI/2))*(Math.PI/2);
                    e.z = Math.round(e.z/(Math.PI/2))*(Math.PI/2);
                    c.quaternion.setFromEuler(e);
                });
                this.pivot.rotation.set(0,0,0);
            }

            // --- Win Logic (FIXED) ---
            checkWin() {
                // Don't trigger if shuffling
                if (this.isShuffling) return;

                if (!this.isGameActive || this.moveCount === 0) return;

                let solved = true;
                const epsilon = 0.1;

                for (let c of this.cubies) {
                    const distPos = c.position.distanceTo(c.userData.initialPos);
                    if (distPos > epsilon) {
                        solved = false;
                        break;
                    }

                    const angle = c.quaternion.angleTo(c.userData.initialQ);
                    if (angle > epsilon) {
                        solved = false;
                        break;
                    }
                }

                if (solved) {
                    this.isGameActive = false;
                    clearInterval(this.timerInterval);
                    const t = document.getElementById('toast');
                    t.classList.add('show');
                    setTimeout(() => t.classList.remove('show'), 3000);
                }
            }

            // --- Public API ---
            move(face, dirMultiplier = 1) {
                const map = { 'R': ['x', 1, 1], 'L': ['x', -1, -1], 'U': ['y', 1, -1], 'D': ['y', -1, 1], 'F': ['z', 1, -1], 'B': ['z', -1, 1] };
                const [axis, index, baseDir] = map[face];
                this.rotateLayer(axis, index, baseDir * dirMultiplier);
                this.startTimer();
                this.incrementMoves();
            }

            shuffle() {
                if(this.isAnimating) return;
                this.resetStats();
                this.isShuffling = true; // Set flag

                const axes = ['x','y','z']; 
                const idxs = [-1,0,1]; 
                const dirs = [1,-1];
                
                let i = 0;
                const totalMoves = 20;
                const animSpeed = 100; // Fast shuffle speed

                // Recursive function to chain animations
                const nextMove = () => {
                    if (i >= totalMoves) {
                        this.isShuffling = false; // Clear flag
                        this.startTimer(); // Start the game clock
                        return;
                    }

                    const a = axes[Math.floor(Math.random()*3)];
                    const idx = idxs[Math.floor(Math.random()*3)];
                    const d = dirs[Math.floor(Math.random()*2)];

                    // Execute move with animation
                    this.rotateLayer(a, idx, d, true, animSpeed);
                    
                    i++;
                    // Wait for animation to finish before next move (plus small buffer)
                    setTimeout(nextMove, animSpeed + 10);
                };

                nextMove();
            }

            reset() {
                if(this.isAnimating) return;
                this.resetStats();
                this.createCube();
                this.camera.position.set(6,5,8);
                this.camera.lookAt(0,0,0);
            }

            startTimer() {
                if(!this.isGameActive) {
                    this.isGameActive = true;
                    this.moveCount = 0;
                    this.startTime = Date.now();
                    clearInterval(this.timerInterval);
                    this.timerInterval = setInterval(() => {
                        const s = Math.floor((Date.now()-this.startTime)/1000);
                        const m = Math.floor(s/60);
                        document.getElementById('timer').innerText = `${m.toString().padStart(2,'0')}:${(s%60).toString().padStart(2,'0')}`;
                    }, 1000);
                }
            }

            incrementMoves() {
                this.moveCount++;
                document.getElementById('move-count').innerText = this.moveCount;
            }

            resetStats() {
                this.isGameActive = false;
                this.isShuffling = false;
                clearInterval(this.timerInterval);
                document.getElementById('timer').innerText = "00:00";
                document.getElementById('move-count').innerText = "0";
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                TWEEN.update();
                this.controls.update();
                this.renderer.render(this.scene, this.camera);
            }
        }

        // Start Game
        const game = new RubiksGame();
        window.game = game;
    </script>
</body>
</html>
